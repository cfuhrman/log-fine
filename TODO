# -*- mode: org -*-

#+TODO: TODO BLOCKED | DONE CANCELED

* DONE [#B] Rename Template->_templateValidate()                  :templates:
  CLOSED: [2011-12-02 Fri 12:51]
  - CLOSING NOTE [2011-12-02 Fri 12:52] \\
    Completed.  ~_templateValidate()~ has been replaced with
    ~_placeholderValidate()~

  Rename ~Template->_templateValidate()~ to some other method name
  that has the word 'placeholder' in it.
* CANCELED [#C] Create Log::Fine::Handle::SMTP                      :handles:
  CLOSED: [2012-05-29 Tue 17:10]
  - CLOSING NOTE [2012-05-29 Tue 17:11] \\
    Canceled.  I'm going to subclass this instead.

  Create a new handle for simple email delivery.  This method will use
  the standard Net::SMTP module for email delivery rather than the
  fully-featured Email::Sender module.
* DONE [#A] Re-organize Log::Fine::Handle::Email functionality
  CLOSED: [2012-05-30 Wed 16:01]
  - CLOSING NOTE [2012-05-30 Wed 16:01] \\
    Done

  This would work as follows:

  1) User would instantiate a Log::Fine::Handle::Email object,
     optionally passing it the name of the submodule to load

  2) Email handle would then determine the appropriate class to load
     and return the appropriate instance

  3) Note that the default will remain using the Email::Sender module
     for email delivery since it's the most flexible

** Minor API change

    - Addition of hash item "module" to constructor for specifying
      Email module to use. Default will be EmailSender.

    - ~msgWrite()~ must now be subclassed.

** Task Log

   [2012-05-30 Wed 15:56] Successfully reorganized
   Log::Fine::Handle::Email and added two new submodules:

   - Log::Fine::Handle::Email::EmailSender, which uses the
     Email::Sender module for delivery

   - Log::Fine::Handle::Email::MIMELite, which uses the MIME::Lite
     module for delivery

** DONE [#A] Get Email changes to release status[6/6]               :release:
   CLOSED: [2012-06-14 Thu 09:48]
   - CLOSING NOTE [2012-06-14 Thu 09:48] \\
     This was done ages ago

   - [X] Come up with additional testing scenarios, if necessary

   - [X] Review POD documentation to make sure it's accurate

   - [X] Perltidy changed code

   - [X] Perhaps come up with testing to multiple addresses?

   - [X] Test on multiple platforms

   - [X] Release unto the world



* TODO [#C] Brainstorm ideas for LOGFINE-0-61                    :brainstorm:

  Ideally, I'd like to get Log::Fine "enterprise-ready", by adding a
  number of features and improvements aimed at stability

** Allow for Handle enabling/disabling

   This would involve the addition of the following methods to
   ~Handle.pm~:

    - ~enable()~

    - ~disable()~

   To facilitate this, a Logger object must be able to reference a
   handle by name, so the following changes would have to be made to
   ~Logger.pm~:

    1) Add new method, ~handleByName~ for retrieving a handle by its
       name.  Would take a string representing a handle name.  If it
       can't find the associated handle, then return undef.

    2) Add new method, ~listHandles~ for retrieving a list of
       registered handles.

    Also, ~isLoggable~ would have to handle enabled or disabled
    handles

    Probably not going to implement this without a good use case, but
    listing it here anyway.

** Add internal logging method

   Add the ability for Log::Fine to log itself.  By default, use a new
   handle, ~Null~ and log to that (any logging there goes into the
   ether).  The user can specify one or more handles on construction,
   like so:

   #+BEGIN_SRC perl
   use Log::Fine;
   use Log::Fine::Handle::Console;
   use Log::Fine::Levels::Syslog qw( :masks );

   my $loghandle =
       Log::Fine::Handle::Console->new(
           name => 'int_logger',
           mask => LOGMASK_EMERG | LOGMASK_ALERT | LOGMASK_CRIT,
           use_stderr => 1,
       );

   my $log = Log::Fine->new(int_log_handle => [ $loghandle ]);
   #+END_SRC

   This would create a new internal logger object.

** Have ~registerHandle()~ accept more than one Handles

   Just need to have ~registerHandle()~ check to see if it's being fed
   an array ref and then make sure all elements in that array are
   ~Handle~ objects

** Allow ~_fatal()~ to be given its own callback

   Have ~_fatal()~ detect if it has a custom callback function and
   execute that instead of the default code

   #+BEGIN_SRC perl
   use Log::Fine;

   my $errorcount = 0;

   my $log = Log::Fine->new(fatal_cb => \&myfatal);

   sub myfatal {
       my $class = shift;
       my $msg   = shift;

       $errorcount++;

       printf ("%03d: %s said %s\n",
               $errorcount, $class, $msg);

   }

   #+END_SRC

** Check FileHandles in ~Handle::File~ objects

   Need to make sure we can print and whatnot in ~Handle::File~
   objects.  Might also want to make sure directory exists before we
   instantiate.


